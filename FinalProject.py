"""
Final project for CS2810 by Oliver Nemec
Written in Python 3.10
"""
import os
import numpy as np
import cv2
import sys


def euclidish_distance(img1, img2):
    """
    Computes the euclidean distance without taking the square root (to reduce runtime) between the corresponding 3D RGB
    arrays of two images
    :param img1: First image to compare
    :param img2: Second image to compare
    :return: the distance as a float
    """
    return np.sum(np.absolute(np.subtract(np.square(img1), np.square(img2))))


def f_score(p, r):
    """
    Calculates the f-score given the precision (p) and recall (r)
    :return: the f-score as a float
    """
    p_len = len(p)
    # make sure denominator of 0 doesn't error
    with np.errstate(divide='ignore', invalid='ignore'):
        return [np.divide(2 * p[i] * r[i], (p[i] + r[i])) for i in range(p_len)]


def read_img_dir(img_dir, res):
    """
    Given a directory img_dir, all subdirectories will be added as keys to a dict and images inside added as resized
    numpy arrays
    :param res: the resolution of the numpy arrays to resize the images to
    :param img_dir: the parent directory containing the subdirectories with images
    :return: a dictionary with each key being the names of the classes or sub-folders and each key storing an array of
    numpy arrays that contain the resized image data
    """
    img_dict = {}
    # for each folder in the training directory, create a key with the folder name in img_dict
    for folder in os.scandir(img_dir):
        if folder.is_dir():
            fn = folder.name
            img_dict[fn] = []
            # for each image file in that directory, try appending to the array at the given key a resized numpy
            # array of the image data
            cur_folder = os.path.join(img_dir, fn)
            for f in os.listdir(cur_folder):
                if f.endswith(tuple(["png", "jpg", "jpeg"])):
                    # try opening the file, resizing, and appending to that key within the dictionary
                    try:
                        img_dict[fn].append(
                            np.array(cv2.resize(cv2.imread(os.path.join(cur_folder, f)), (res, res))))
                    except Exception as e:
                        print(str(e))
    return img_dict


class KNN:
    def __init__(self, key_arr, k_val, test_img_dict, train_img_dict):
        """
        Initialize variables for KNN class
        :param key_arr: the keys for the given dictionary
        :param k_val: the chosen k-value for this KNN
        :param test_img_dict: the dictionary of images to test against the trained data
        :param train_img_dict: the dictionary of images to compare to
        """
        self.key_arr = key_arr
        self.k_val = int(k_val)
        self.test_img_dict = test_img_dict
        self.train_img_dict = train_img_dict
        self.keys_len = len(key_arr)
        self.prediction_arr = np.zeros((self.keys_len, self.keys_len))

    def insert_k_nearest(self, k_nearest, dist, key_comp, actual_key_index):
        """
        Inserts the current image into the k_nearest array sorted from least to greatest distance if appropriate
        :param k_nearest: array of dictionaries storing the k nearest neighbors' distance, predicted key, and expected
        key
        :param dist: the calculated distance
        :param key_comp: the string of the predicted key from the image compared to
        :param actual_key_index: the true index of the key expected
        :return: the new k_nearest array with the current image inserted if appropriate
        """
        # insert the distance into the sorted k-nearest array if appropriate
        j = 0
        # check positions < k
        while j < self.k_val:
            # if no entry exists, set the entry
            if k_nearest[j] is None:
                k_nearest[j] = dict(value=dist, predicted_key=self.key_arr.index(key_comp),
                                    expected_key=actual_key_index).copy()
                break
            # if current distance is closer, insert current entry
            elif k_nearest[j].get("value") > dist:
                k_nearest.insert(j, dict(value=dist, predicted_key=self.key_arr.index(key_comp),
                                         expected_key=actual_key_index).copy())
                # if the list is longer than k, remove last element
                if len(k_nearest) > self.k_val:
                    k_nearest.pop(self.k_val)
                break
            j += 1
        return k_nearest

    def get_closest_key_index(self, k_nearest):
        """
        Fetches the most commonly occurring key index from the k_nearest array of dictionaries (weighted by inverse
        square of the index)
        :param k_nearest: array of dictionaries generated by insert_k_nearest
        :return: an integer index for the most commonly occurring key
        """
        closest_key_index = 0
        key_counter = [0] * self.keys_len
        # for each entry in k_nearest add to the corresponding key counter
        index = 1
        for k in k_nearest:
            curr = k.get("predicted_key")
            key_counter[curr] += (1 / (index * index))
            # if the currently added to key is greater, set it as the max
            if key_counter[curr] > key_counter[closest_key_index]:
                closest_key_index = curr
        return closest_key_index

    def knn(self):
        """
        Performs the KNN classification on the data stored in this class.
        :return: returns an array with key predictions on the left and expected keys on top (ordered by key_arr)
        """
        # Loops through all keys in images we are testing to classify
        for key_test in self.key_arr:
            actual_key_index = self.key_arr.index(key_test)
            # Loops through all images for a given key for test images
            for img_test in self.test_img_dict.get(key_test):
                k_nearest = [None] * self.k_val
                # Loop through all images in training data to compare and find the closest ones
                for key_comp in self.key_arr:
                    for img_comp in self.train_img_dict.get(key_comp):
                        k_nearest = self.insert_k_nearest(k_nearest, euclidish_distance(img_test, img_comp), key_comp,
                                                          actual_key_index)
                self.prediction_arr[self.get_closest_key_index(k_nearest)][actual_key_index] += 1
        return self.prediction_arr


class Stats:
    def __init__(self, result_arr, keys):
        """
        Initialize variables for Stats class
        :param result_arr: resulting array from knn()
        :param keys: the keys from key_arr
        """
        self.result_arr = result_arr
        self.keys = keys
        self.result_len = len(keys)

    def get_tp(self, class_index):
        """
        Gets the true positive of result_arr
        :param class_index: the index of which class is assumed positive
        :return: the float value of the true positive
        """
        return self.result_arr[class_index][class_index]

    def get_fp(self, class_index):
        """
        Gets the false positive of result_arr
        :param class_index: the index of which class is assumed positive
        :return: the float value of the false positive
        """
        return np.sum(self.result_arr[class_index]) - self.get_tp(class_index)

    def get_tn(self, class_index):
        """
        Gets the true negative of result_arr
        :param class_index: the index of which class is assumed positive
        :return: the float value of the true negative
        """
        return np.sum(self.result_arr) - self.get_fn(class_index) - self.get_fp(class_index) - self.get_tp(class_index)

    def get_fn(self, class_index):
        """
        Gets the false negative of result_arr
        :param class_index: the index of which class is assumed positive
        :return: the float value of the false negative
        """
        return np.sum(self.result_arr[:, class_index]) - self.get_tp(class_index)

    def accuracy(self):
        """
        Gets the accuracy of result_arr
        :return: the float value of the accuracy of result_arr
        """
        # make sure denominator of 0 doesn't error
        with np.errstate(divide='ignore', invalid='ignore'):
            return np.divide(np.sum([self.result_arr[i, i] for i in range(len(self.result_arr[0]))]),
                             np.sum(self.result_arr))

    def precision(self):
        """
        Gets the precision of result_arr
        :return: the float value of the precision of result_arr
        """
        # make sure denominator of 0 doesn't error
        with np.errstate(divide='ignore', invalid='ignore'):
            return [np.divide(self.get_tp(i), np.sum(self.result_arr[:, i])) for i in range(self.result_len)]

    def recall(self):
        """
        Gets the recall of result_arr
        :return: the float value of the recall of result_arr
        """
        # make sure denominator of 0 doesn't error
        with np.errstate(divide='ignore', invalid='ignore'):
            return [np.divide(self.get_tp(i), np.sum(self.result_arr[i])) for i in range(self.result_len)]

    def print_arr(self):
        """
        Prints result_arr with context and keys listed
        :return: none
        """
        print("Resulting array: (keys appear in the following order)")
        print(self.keys)
        print(" | Actual classifications ---> ")
        print(" | Predictions")
        print(" V")
        print(self.result_arr)

    def show_stats(self):
        """
        Prints the stats for result_arr
        :return: none
        """
        acc = self.accuracy()
        pre = self.precision()
        rec = self.recall()
        fs = f_score(pre, rec)

        print("ANALYSIS:")
        print("{:<20} {:<12} {:<12} {:<12} {:<12}".format("", "Accuracy", "Precision", "Recall", "F-Score"))
        for i in range(self.result_len):
            print("{:<20} {:<12.6} {:<12.6} {:<12.6} {:<12.6}".format(self.keys[i], acc, pre[i], rec[i], fs[i]))


def main(img_dir, k_val):
    """
    Takes the directory of images and using KNN classifies them
    :param img_dir: the directory with training and testing images
    :param k_val: the amount of points to use in KNN
    :return: none
    """
    res = 64  # the resolution for the image matrices
    train_img_dict = read_img_dir(os.path.join(img_dir, "train"), res)  # dictionary storing the training data
    key_arr = list(train_img_dict.keys())
    test_img_dict = read_img_dir(os.path.join(img_dir, "test"), res)
    k = KNN(key_arr, k_val, test_img_dict, train_img_dict)
    s = Stats(k.knn(), key_arr)
    s.print_arr()
    s.show_stats()


if __name__ == "__main__":
    """
    Checks to see if correct amount of parameters is given, then runs main if yes
    """
    # if 3 arguments are given
    if len(sys.argv) == 3:
        if not os.path.isdir(sys.argv[1]):
            print("Please supply a valid directory for images with sub-folders \"test\" and \"train\".")
        elif not str.isdigit(sys.argv[2]) or int(sys.argv[2]) % 2 == 0:
            print("Make sure the argument after the data directory is an odd integer value for k.")
        else:
            main(sys.argv[1], sys.argv[2])
    # otherwise, print an error message explaining how to use this program
    else:
        print("Incorrect number of parameters supplied.\n"
              "Provide a data directory, and k-value like: "
              "\"python3 FinalProject.py pneumonia 7\"")
